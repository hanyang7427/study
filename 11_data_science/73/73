2.多项式拟合(应用的依然是最小二乘法)
泰勒定理：任何可微的函数都可以用一个N多项式来表示，而比N次幂更高阶的部分可作为无穷小量被忽略不计。
f(x) = p0x^n + p1x^n-1 + p2x^n-2 + ... + pn
                                               | n=5
f(x) = p0x^5 + p1x^4 + p2x^3 + p3x^2 + p4x + p5
x0 -> y0
x1 -> y1
...
x5 -> y5
p0x0^5 + p1x0^4 + ... + p5 = y0
p0x1^5 + p1x1^4 + ... + p5 = y1
...
-> [p0, p1, ..., p5]
numpy.polyfit([x0, x1, ..., x5], [y0, y1, ..., y5])
-> [p0, p1, ..., p5]
numpy.polyval([p0, p1, ..., p5], [x0, x1, ..., x5])
-> [y0, y1, ..., y5]
numpy.roots([p0, p1, ..., p5])
->多项式方程f(x)=0的根
numpy.polyder([p0, p1, ..., p5])
->一阶微分函数f'(x)的系数[q0, q1, ..., q4]。
代码：poly.py
3.符号数组
a = np.array([5, -4, 3, 0, -1])
1)numpy.sign(a) -> [1, -1, 1, 0, -1]
2)numpy.piecewise(数组, 条件列表, 取值列表)
将数组中符合条件列表中每个条件的元素，用取值列表中相应的元素来表示。
numpy.piecewise(a, [a<0, a==0, a>0], [-1, 0, 1])
-> [1, -1, 1, 0, -1]
净额成交量(OBV)
代码：obv.py
4.矢量化
将一个针对单一数值的标量运算变为针对一组数值的矢量运算。
代码：vector.py
模拟交易
代码：sim.py
5.数据平滑
1)窗函数卷积
2)多项式拟合
代码：smr.py
y = f(x)
y = g(x)
y = f(x) - g(x) = m(x) = 0
numpy.ploysub(p1, p2) -> p3
四、矩阵和一般函数
1.矩阵
numpy的矩阵是matrix类的对象，matrix的ndarray的子类，二者计算规则不同。
代码：mat.py
2.一般函数
所谓一般函数实际上是一个numpy.ufunc类型的对象，是一个
可调用对象，可以被当作函数调用。该对象可以在其被调用之前
，将特定的函数及其参数信息封装在其内部，以实现延迟调用。
代码：ufunc.py
3.几个预定义的一般函数
1)加法
代码：predef.py
2)除法
A.真除：无论运算数是整型还是浮点，运算结果都是浮点数，
保留小数
numpy.true_divide()
numpy.divide()
/
[5 5 -5 -5] <真除> [2 -2 2 -2] -> [2.5 -2.5 -2.5 2.5]
B.地板除：运算数整数或者浮点，运算结果也是整数或浮点，
小数部分向下取整
2.5 -> 2
-2.5 -> -3
[5 5 -5 -5] <地板除> [2 -2 2 -2] -> [2 -3 -3 2]
另外：
天花板除：运算数整数或者浮点，运算结果也是整数或浮点，
小数部分向上取整
2.5->3
-2.5->-2
[5 5 -5 -5] <天花板除> [2 -2 2 -2] -> [3 -2 -2 3]
截断除：运算数整数或者浮点，运算结果也是整数或浮点，
直接丢弃小数部分
[5 5 -5 -5] <截断除> [2 -2 2 -2] -> [2 -2 -2 2]
3)取余(模)(余数=被除数-除数x商)
A.地板膜：地板除的余数，这样的余数与除数总是同号的
numpy.remainder()
numpy.mod()
%
[5 5 -5 -5] <地板除> [2 -2 2 -2] = [2 -3 -3 2]...[1 -1 1 -1]
B.截断模：截断除的余数，这样的余数与被除数总是同号的
numpy.fmod()
[5 5 -5 -5] <截断除> [2 -2 2 -2] = [2 -2 -2 2]...[1 1 -1 -1]
代码：div.py